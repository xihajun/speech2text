大家好,我是小木头,欢迎大家来到我的视频频道。
在AI应用开发中,提示词的编写占了非常重要的比重,这也是AI应用成功的关键。
那大家在日常应用开发中是否有遇到过不知道该如何编写提示词,
或无法有效的编写提示词来引导模型帮助我们完成任务呢?
今天我们就来分享一个提示词编写的技巧,HEPA Metaprompt原提示词。
在Anthropic官方的用户手册子里,对提示词工程做了非常详细的介绍,我们就是基于这部分的内容来分享。
Prompt Engineering,也就是提示词工程,是一门经验主义科学涉及到迭代和测试提示词来优化其性能。
在工程周期中,大部分精力并非用于编写提示词。
大部分的工程时间会花在开发强大的评估集上,然后根据这些评估来进行测试并迭代。
我们来看一个典型的提示词开发的生命周期。
根据文档介绍,Anthropic建议采用原则性的测试驱动的方式来确保提示词性能最优。
我们逐步的来看一看在这个图表中所分享的每一个在提示词开发阶段中的关键流程。
首先是第一步定义任务和成功的标准。这是第一步,也是最关键的一步。
我们需要清晰的定义期望,比如向Claude提供的大模型所执行的具体任务。
它可以是实体提取,也可以是问答或者是文本摘要,甚至更复杂的任务,比如像代码生成或者创意写作。
这里有几个要考虑的关键成功标准。第一方面是性能和精确性或准确性,模型在任务上的表现如何。
第二个是延迟,模型的可接受响应时间是多少,这取决于应用的实时要求和用户的期望,因此这个跟用户需求是非常相关的。
最后一个方面就是价格,运行模型的预算是多少,我们知道在模型的使用上总是有成本的,
那么考虑因素包括了比如每次API调文的成本,模型的大小和使用频度等等。
在定了任务和成功标准后,接下来要做的就是开发测试用力,它应该包含典型施力和一些边界案例,以确保提示词具有鲁棒性。
从一开始就定义良好的测试用力,可以使得开发者能够客观地衡量提示词在成功标准下的表现。
在工程化周期的第三个环节,就是对提示词进行初步的工程化,在施力图这里它是第二部分Engineer Preliminary Prompt。
在这一步中我们会制作一个初步的提示词,概述任务定义,然后响应的特征,以及像Claude这些模型所需的任何上下文。
在这个环节最好还添加一些像Claude应遵循的规范输入和输出的施力,这个初步的提示词将作为后续改进的起点。
第四步是根据测试用力来测试提示词,使用初步生成的提示词将测试用力匮送到Claude,仔细评估模型的响应是否符合预期输出和成功标准。
使用一致的评分标准,无论是人工评估,还是与预期的回答进行比对,还是基于评分标准的Claude的另一个实例,这一步关键的是要有一种系统化的评估性能的方法。
第五步就是对提示词进行改进,这是根据上一步的结果迭代的来改进提示词,以提高测试用力的性能,并更好满足成功的标准。
要注意的是不要过度优化与一组狭窄的输入,这样可能会导致过拟和泛化的能力较差。
最后就可以发布完善的提示词,一旦获得了在测试用力中表现良好且符合成功标准提示词,就可以将其部署到应用程序中,在实际的应用中来监控模型的性能,并准备根据需要进行下一步的改进。
关于最后一步,大家心里也需要有预期,很有可能会出现未在初始测试机中预料到的一些边界案例,也就是Edge case。
在这整个过程中,值得从最能适任的模型和无约数的提示词长度开始,来建立性能的上限,一旦达到所需的输出质量,来尝试优化。
如利用更短的提示词或更小的模型,以减少延迟并降低成本。
在下面,我们可以看到用户手写给到了一些提示词工程化的技巧或者技术。
我们在这里要分享的是在这里最后提供的jahepper meta prompt,原提示词这么一个技巧。
我们现在就点击它。
这就是我们今天要介绍的另一部分重要内容,jahepper meta prompt,原提示词。
先介绍一些背景信息,为什么会有这个meta prompt。
刚才我们介绍了提示词的工程化,那么有时候使用AI模型最困难的部分恰恰是弄清楚如何有效地提示它,也就是如何有效地编写提示词。
为了帮助解决这个问题,Anthropic创建了实验性的辅助提示词meta prompt。
可以指导Code,可以指导Code生成针对特定任务的高质量提示词。
它给到了我们一些指令,这些指令在notebook当中,其中也包含了可以运行的代码。
来帮助我们让Code来创建提示词。
我现在在这里已经打开了这个链接,大家可以在这里参考一下。
根据这份notebook介绍,大家可以在自己的drive当中保存一份拷贝,并计阅Anthropic API key来测试并使用这份代码。
我在这里已经做了一份拷贝。现在来介绍一下究竟meta prompt是一个什么东西,我们如何使用它。
我们根据notebook来,首先是需要在这里连接一下环境,然后安装Anthropic Python的开发波。
我在这里已经配置了Anthropic API key这个密钥,大家可以按照自己需要来配置。
首先安装Anthropic,接下来配置Anthropic API key,模型选用的是Code3 Opus。
通过API key来构建一个Anthropic客户端,一个client。
我们在这里先让它运行。接下来介绍重点部分。
这内容包含了三部分,第一个是原题词本身meta prompt,接下来是如何使用它。
最后可以基于Code生成的题词来测试究竟它的效果如何。
首先来看看原题词meta prompt,这个题词大家第一次打开的时候,这儿会有个链接显示代码suecode。
这是非常长的一个题词,在目前随着大模型的不断发展,上下文环境越来越大,那么现在这种长的题词也越来越不成为一个问题。
我们可以尽自己所能让这个题词能够尽量的完胜,指令尽量的明确。
在这里我们可以看看它究竟这个原题词是如何编写的。
大概的意思就是说在这个原题词当中,会利用这一串文本告诉模型需要明确而清晰的指令和示例,来帮助我们生成一份题词。
模型会基于这份原题词来了解究竟要完成一个什么样的任务,我们后面会根据具体的示例来分享究竟是做什么。
在这里,关于指令、关于输入,分别有标签来包裹。
Input这里可以看到有一些变量FAQ、question,在instructions这里给到了一系列的指令。
这个instructions是包含在一个大的task instruction example这里的。
这个原题词当中包含了若干个task instruction example,也就是指令的示例。
它们分别覆盖了一些不同的题词词场景。
比如像这个示例当中,它的任务是什么呢?就是检查是否两个句子说的是同一个事情。
底下就会通过两个变量来标示是哪两个句子。
在使用这个题词词的时候,就可以通过变量的替换来完成填写。
在这里指令部分介绍了究竟该怎么做。
有两个句子,第一个句子是什么,第二个句子是什么。
接下来回答yes或no。
yes表示它模型认为这两个句子说的是同一个事情,那就是返回yes,否则返回no。
这就是一个例子。
在这里给到了我们非常长的一个原题词。
那当我们要说什么是原题词词呢?可以简单地认为这个就是原题词词。
在后面的一些例子当中,example当中,我们看这里还有一些函数调用方面的例子给到模型。
目的还是在于帮助模型尽可能多地理解不同的任务执行场景中,它应该如何提供题词词给用户。
那么究竟这个原题词词它会做什么呢?
我们马上往下看,在quick start这里。
我对这里做一些修改,如果回到原始版本,在这里可以看到它究竟是要完成什么任务。
在这里就是第二步,我们使用这个原题词词,需要给到一些变量,一个是task,表示要完成什么任务。
第二个是variables,变量,当我们不填写变量的时候,会让模型来帮我们动态的决定和生成该需要什么样的变量。
在它这里给到的一个任务是什么呢?Draft an email responding to a customer complaint,写一封邮件来回复客户的抱怨或者是投诉。
task是这么一句话,应该我们可以认为它就是给到模型那段题词词。
现在要做的事情就是将这段题词词交给原题词词,基于此让模型帮助我们在原题词词的支持下生成一个更高质量的题词词。
大家可能还是挺疑惑究竟是在干什么。那么我们回到这里,我们这个势力当中对这个任务这个字段做了调整。
这个任务是做什么呢?是希望能够让模型帮助我们识别一个表结构的数据是基于行的还是基于列的。
如果大家对这一点还是有什么疑惑呢?不要紧,我们马上在后面执行代码的时候,大家可以看到模型是怎么回答的。
那它给到我们还会包含了推理的过程,这样我们就可以更加合理的去理解究竟它是否能够帮助我们更好的编写这个题词词。
那接下来我们往下走,我们这里并不需要指定任何变量,模型会帮助我们去识别在这个题词当中是否需要变量,需要什么样的变量。
那我们现在逐行的执行一下这些代码,我看看刚才执行了两行,把原题词词的定义执行。
接下来就来到这里,我们来定义任务,因为没有变量,所以在这个变量字副串的生成上也是空的,可以看到这也是空的。
那接下来就会对这个原题识词做替换,我们在原题识词当中由双花括号task这个字副串来标示任务,我们就会将task替换进去。
接下来是这个assistent partial,这个是做变量字副串的替换,我们当然这里刚才可以看到并没有字副串,因此在这里会生成一个,并不会在这里追加任何字副串进去,它是空的,所以input这里是空的。
那现在就通过client,这个是anthropic client,选择的模型刚才我们介绍了用的是opus,在这里我们用的opus模型,用anthropic来完成的API调用,这个客户端就去做API调用,传递的参数就有一系列的消息message,第一个消息是用户的题词词,这就是刚才通过原题词词替换出来的,接下来还有这个输入,
它是作为assistent partial这个来传递的,当然我们刚才看到了这里variable string是空的,如果大家好奇这个文本输出的到底是什么,我们可以来看看,我们看一看就能明白究竟它是怎么做的。
在这里大家可以看到它输出的信息就是现在这个情况,多了一些变量,ex table,另外在这里下还有一些指令,我们来看看它介绍了一些什么信息,它说you will be provided with a table of data in a table tag like this,
所以它会用这两个标签来将我们的表结构的数据包含在题词词中,接下来给到一些指令,任务是什么,可以看到它写的比咱们刚才短短的一句话更加丰富,我们可以认为它有更清晰的指令。
最后还给到了一些建议或者是一些指令,希望模型能够写出它的reasoning的过程以及analysis,通过这个reasoning标签把它包裹起来,含在里头,不仅如此,还需要将最终的determination这个决定和判断通过orientation这个标签把包含起来,最后还给到了更多的指令。
我们如何去判断是机遇行还是机遇列呢?这里就告诉它是期望它关注于semantics of the row and column labels to make your determination, not the specific formatting or visual layout of the table。
这个意思就是期望能够让模型关注行和列的标签的语意,这样来决定它究竟是机遇行的还是机遇列的。
好吧,总结一下。在这里,基于刚才咱们给的短短的一句提示词,那么模型能够根据Matter prompt来让模型给到我们改进后的提示词,这个提示词就包括了更丰富的信息,包含了变量,也包含了更清晰的指令,甚至还包含了关于模型该如何去做reasoning,如何去做analysis,最后得到它的determination。
好吧,那接下来我们继续向后面执行。在后面这里有几个辅助函数,帮助我们对文本,对数据进行处理,包含了从tag当中抽取信息。
因为刚才我们可以看到在这个提示词当中,它指导模型在输出的时候会用orientation,会用reasoning这些tag来包裹输出的信息,我们就需要从reasoning,需要从orientation这个标签中提取,这些信息就可以通过这些帮助函数来帮助我们。
那接下来我们就要做的事情呢,来看看究竟会得到一些什么。在这里呢,我们就基于模型的输出消息,这个文本来做的信息提取,在这里打印出了变量以及提取出来的提示词模板,变量就一个table,通过这个变量用户可以做文本的替换,将实际的表格数据或表结构的数据呢,替换了提示词模板当中。
抽取出来的提示词模板呢,就是下面这一段,这个模板当中有一个变量table,这是我们会替换的。
那讲到这里,大家应该就清楚这个meta prompt究竟是做什么的,它能够帮助我们基于大模型来实现什么样的功能。
最后呢,就是来做测试了,我们现在得到了模板,提示词模板和变量,那在这里呢,就可以来完成一些问答。
在这里呢,我们来执行一下这部分代码。
它会有一个输入框,让我输入数据,也就是这个table表结构的数据。我在这里呢,参考了一份PDF,大家可以看一下这个PDF表格,还是挺明显的,它是以列为一个分类,它就是每一列有不同的分类,data relationships, motivation, problem solving,那么这四个维度来进行的数据的呈现。
我已经提前的将这个表格转换成了markdown语法的表结构,来看一下在这里,或许并不是那么好理解,那么我们直接将它拷贝粘贴到刚才的代码的执行中,作为输入。
现在呢,就来到这里粘贴进去,我们可以暂时不去关心它究竟这个数据长什么样,我们不需要很好的阅读和理解,大家只要知道是从这个PDF表格中抽取出来就好。
现在呢,就提交给模型进行问答。
可能需要一些时间执行,那在这里呢,已经完成了,可以看看它的输出究竟是什么样的。Code的输出是如下这些信息,它给到了我们它的分析,分析是在这个reasoning的标签当中将它的推理做了介绍,并且在最后通过orientation这个标签来标记了究竟它的结论是什么。
首先看结论,它是column oriented,这是我们期望的,因为刚才我们介绍了,它每一列是一个不同的分类,一个category或者topic,所以还是挺明显的是列,基于列的一个表结构数据。
那为什么呢?它说在行大标签中有四个标签data relationships, motivation, problem solving,看起来是命名了不同的属性或者是元素,在如何提高学生的出勤率attendance。那后面我们就不介绍了,那这就是我们如何来使用metaprompt原题诗词。
那希望这个原代码的执行能够给大家一些帮助,更好地理解什么是原题诗词,它的作用是什么。
Anthropic发布的metaprompt原题诗词,目的还是在帮助在工程化的过程中,更好地将题诗词转换成具有更高质量的指令,帮助大模型更好地理解用户的需求,能够更好地完成特定的任务。
在我们刚才这个例子当中,通过这一系列的操作,将一条本是比较频繁不太具有清晰指令的题诗词,转换成了更加具有指导性,能够让模型更好地理解究竟该做什么,该怎么做,以及它的结果或者结论响应该以如何或以什么样的形式返回给用户。
有兴趣的同学,我觉得可以将今天这个代码分享中的这些实例代码封装抽象出接口或者服务,在自己的应用场景中来测试一下,看看是否能够帮助自己将题诗词的质量再提高一些。
有兴趣的同学,赶紧来尝试一下,我会将今天用到的代码和文档的链接都放在视频描述中。
感兴趣的同学,也欢迎在测试或使用后在评论区给我们留言反馈,看看哪些方面我们可以再进一步改进,让这个题词词工具更加好用。
好吧,咱们今天的分享就到这里,感谢大家收看,我们下次视频分享再见,同学们拜拜。
